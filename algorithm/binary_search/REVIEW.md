## 二分探索ができる条件

「境界より左は全部ダメ（false）で、右は全部OK（true）になる」

これが崩れる（T→F→T みたいに揺れる）なら二分探索はできません。

## 注意点

### 何を二分探索しているかを明確にする

> e.g. 「A[i] >= K を満たす 最小の i を探す」

この時点で lower_bound 

### 区間の意味を必ず決める

二分探索は「配列」ではなく 区間 を扱っている

```
探索区間: [lo, hi)
意味:
- lo: 条件を満たさないことが確定した最大位置
- hi: 条件を満たすことが確定した最小位置
```

### ループ内で「必ず区間が縮むか」を確認

❌ ダメな例

```go
lo = mid   // mid == lo になる可能性あり
```

✅ OK

```go
lo = mid + 1
hi = mid
```

### mid は「答え候補」か「捨てる側」か？
mid を見たとき、必ずどちらかを言語化する

例（lower_bound）：
```go
A[mid] >= K
→ mid は 答え候補 → hi = mid

A[mid] < K
→ mid は 絶対ダメ → lo = mid + 1
```

### 終了条件は lo == hi にする

### 「存在しないケース」を最初から設計に含める

二分探索は"見つかる", "見つからない"の両方を同じロジックで扱える のが強み。
